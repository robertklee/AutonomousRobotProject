#pragma config(Sensor, in3,    IRsensorRight,  sensorReflection)
#pragma config(Sensor, in4,    IRsensorLeft,   sensorReflection)
#pragma config(Sensor, dgtl1,  button1,        sensorTouch)
#pragma config(Sensor, dgtl2,  StateLEDAcquire, sensorDigitalOut)
#pragma config(Sensor, dgtl3,  StateLEDRotate, sensorDigitalOut)
#pragma config(Sensor, dgtl4,  StateLEDForward, sensorDigitalOut)
#pragma config(Sensor, dgtl5,  StateLEDVerify, sensorDigitalOut)
#pragma config(Sensor, dgtl6,  StateLEDAttach, sensorDigitalOut)
#pragma config(Sensor, dgtl7,  StateLEDCompletion, sensorDigitalOut)
#pragma config(Sensor, dgtl11, ultrasonic,     sensorSONAR_cm)
#pragma config(Motor,  port1,           left,          tmotorVex393_HBridge, openLoop)
#pragma config(Motor,  port2,           lift,          tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port10,          right,         tmotorVex393_HBridge, openLoop)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

/**
 * Written by Robert Lee for use in the ENGR 120 Spring 2017 autonomous cable-running robot project.
 * Robert Lee, Calder Staude, Kyle Jarvis, Kyra Teetzen
 */

/* Timer use documentation:
 * T1: used for detecting 10Hz pulses from beacon. DO NOT USE.
 * T2: used for timing find beacon state.
 * T3: used for LED blinking
 * T4:
 */

typedef enum SystemStateType{
    Idle, //stop all motors, initialize global variables
    AcquireStrongestSignal, //spin 360 degrees and track max values received by IR sensors
    RotateToStrongestSignal, //spin in most efficient direction to rotate to the max value
    Forward, //drive to the beacon while calculating if it is off course. Small corrections to trajectory
    VerifyStrongestSignal, //check if robot direction is correct. If not, perform large corrections to trajectory
    Attach, //lower attachment mechanism
    Release, //back up robot and signal task completion
    WallDetected //backs up robot 1 second. Called when robot encounters a wall
} SystemStateType; //used as Finite State Machine state variable

const int ultrasonic_threshold = 14; //threshold distance to trigger wall detection algorithm is 14 inches

const int time_for_360_degrees = 3900; //time robot takes to rotate 360 degrees
const int turnSpeed = 60; //speed at which robot rotates

int light_threshold = 1000; //initial light threshold value.
int diffLevelIRRight = 0; // Delta between maximum and minimum seen in last 0.1 seconds
int diffLevelIRLeft = 0; // Delta between maximum and minimum seen in last 0.1 seconds

int maxDiffLevelIRRight = 0; //keeps track of highest IR value seen by right IR
int timeDiffLevelMeasured = 0; //tracks time at which this maximum was seen

int maxDiffLevelIRLeft = 0; //keeps track of highest IR value seen by left IR

int max_recheck_time = 2000; //if this amount of time has passed, transition from Forward to VerifyStrongestSignal

bool checkLeftDirection = false;
//if true, robot rotates left, right, left when in VerifyStrongestSignal state
//if false, robot rotates right, left, right when in VerifyStrongestSignal state

const int ultrasonic_cable_connection_threshold = 5; //threshold for sonar in cm that triggers attachment process
const int IR_difference_cable_connection_threshold = 3500; // max that is possible is around 3900
//threshold for IR difference levels that triggers attachment process

bool attach_success = false; //if attachment mechanism was successful

void set_LED(int value) {
    //set all LED lights to the given on/off value
    SensorValue[StateLEDAcquire] = SensorValue[StateLEDRotate] = SensorValue[StateLEDForward] = value;
    SensorValue[StateLEDVerify] = SensorValue[StateLEDAttach] = SensorValue[StateLEDCompletion] = value;
} //set_LED

void initialize_LED() {
    set_LED(0); //set all LEDs to off
}//initialize_LED

void initialize_motors() {
    motor[left] = motor[right] = motor[lift] = 0; //set all motors to stopped
}//initialize_motors

void initialize_global_variables() {
    //reset all global variables to initial state
    light_threshold = 1000;

    maxDiffLevelIRRight = 0;
    timeDiffLevelMeasured = 0;

    maxDiffLevelIRLeft = 0;

    checkLeftDirection = false;
    max_recheck_time = 2000;
    attach_success = false;
}//initialize_global_variables

// Perform processing of measurements.
// Should be called with rate of at least 20 Hertz for proper detection of puck.
void monitorLight()
{
    static int minLevelIRRight = 4096;	// Minimum light level seen by right IR sensor
    static int maxLevelIRRight = 0;			// Maximum light level seen by right IR sensor

    static int minLevelIRLeft = 4096;	// Minimum light level seen by left IR sensor
    static int maxLevelIRLeft = 0;			// Maximum light level seen by left IR sensor

    int lightLevel1 = SensorValue[IRsensorRight];
    int lightLevel2 = SensorValue[IRsensorLeft];

    // Check if 100 msecs have elapsed.
    if ( time1[T1] > 100 )  {

        // 100 msecs have elapsed.  Compute delta of light level.

        //prevdiffLevelIRRight = diffLevelIRRight; // used to average past two values to stabilize value
        //prevdiffLevelIRLeft = diffLevelIRLeft; // used to average past two values
        diffLevelIRRight = maxLevelIRRight - minLevelIRRight;
        diffLevelIRLeft = maxLevelIRLeft - minLevelIRLeft;

        // Reset calculation for next 100 msecs.
        maxLevelIRRight = 0;
        minLevelIRRight = 4096;
        maxLevelIRLeft = 0;
        minLevelIRLeft = 4096;
        clearTimer(T1);

    }/*if*/ else {

        // Check for new minimum/maximum light levels.
        if ( lightLevel1 < minLevelIRRight ) {
            minLevelIRRight = lightLevel1;
        }/*else*/ else if ( lightLevel1 > maxLevelIRRight ) {
            maxLevelIRRight = lightLevel1;
        }/*else if*/
        if ( lightLevel2 < minLevelIRLeft ) {
            minLevelIRLeft = lightLevel2;
        }/*if*/	else if ( lightLevel2 > maxLevelIRLeft ) {
            maxLevelIRLeft = lightLevel2;
        } // else
    } // else
} // monitorLight

/**
 * Corroborates left and right IR values to verify if IR signal is coming from a beacon
 *
 * Pre-conditions: global variables maxDiffLevelIRRight, maxDiffLevelIRLeft have been set by VerifyStrongestSignal or AcquireStrongestSignal
 *
 * @return      if the sensor readings match the expected signal from the beacon
 */
bool IRBeaconVisibleCombinedSensors() {
    const int allowable_sensor_variance = 200;
    // allowable difference between left and right IR sensors when robot sees beacon

    if (diffLevelIRLeft > maxDiffLevelIRLeft - allowable_sensor_variance &&
        diffLevelIRRight > maxDiffLevelIRRight - allowable_sensor_variance) {
        //If both left and right IR values are within a allowable variance with the maximum, robot has seen beacon
        return true;
    }//if

    return false;
}//IRBeaconVisibleCombinedSensors

/**
 * Rotates robot 360 degrees while tracking largest IR diff value, to set as a new threshold for robot to
 * use to find the beacon's direction.
 *
 * Pre-conditions:  - global variables maxDiffLevelIRRight, maxDiffLevelIRLeft, and timeDiffLevelMeasured must be initialized to 0
 * Post-conditions: - global variables maxDiffLevelIRRight, maxDiffLevelIRLeft, and timeDiffLevelMeasured are updated with the
 *                    appropriate values for the robot to use to find the beacon
 *
 * @return      the next SystemState to transition to
 */
SystemStateType AcquireStrongestSignalState() {
    const int threshold_variance = 150;
    //allowable variance for sensor value

    if (time1[T2] > time_for_360_degrees) {
        light_threshold = (maxDiffLevelIRRight + maxDiffLevelIRLeft) / 2 - threshold_variance;
        motor[left] = motor[right] = 0;
        //set system threshold for beacon search
        return RotateToStrongestSignal;
    }/*if*/ else {
        motor[right] = -1 * turnSpeed;
        motor[left] = turnSpeed;

        //if left or right IR values are higher than the maximum, remember it
        if (diffLevelIRRight > maxDiffLevelIRRight) {
            maxDiffLevelIRRight = diffLevelIRRight;
            timeDiffLevelMeasured = time1[T2];
        }//if
        if (diffLevelIRLeft > maxDiffLevelIRLeft) {
            maxDiffLevelIRLeft = diffLevelIRLeft;
        }//if

        return AcquireStrongestSignal;
    }//else
}//end of AcquireStrongestSignalState

/**
 * Rotates the robot in the direction of the IR diff value found in AcquireStrongestSignal state
 * Robot rotates in most efficient direction, accounting for its orientation when it finishes its previous state.
 * If beacon is closer to right side of robot, robot rotates to the right. If beacon is closer to left side of robot,
 * robot rotates to the left
 * If robot faces a wall, robot speeds up
 * If robot sees a strong IR signal nearing the values it expects, it slows down
 *
 * Failsafe: if it loses track of the signal, it will continue to spin until it finds it. If 9 seconds
 * have passed, and it has still not found the beacon direction, it likely lost where it is.
 * To prevent an infinite loop, it resets all global variables to initial state, and returns to AcquireStrongestSignal state.
 *
 * Pre-conditions:  - global variables maxDiffLevelIRRight, maxDiffLevelIRLeft have been assigned values
 * Post-conditions: - global variables maxDiffLevelIRRight, maxDiffLevelIRLeft are updated with the
 *                    appropriate values for the robot to use to find the beacon
 *                  - robot is facing toward direction of strongest signal
 *
 * @return      the next SystemState to transition to
 */
SystemStateType RotateToStrongestSignalState() {
    const int turn_speed_facing_wall = 60; //robot turns faster when it's facing a wall
    const int IR_threshold_facing_wall = 1000; //if an object is to be considered a wall, left and right IR must be below this threshold
    const int ultrasonic_threshold_facing_wall = 20; //if an object is to be considered a wall, ultrasonic must be below this threshold
    const int slow_speed = 30; //speed to turn when robot thinks it is almost facing beacon
    const int turnSpeed2 = 40; //default speed to turn at in this state
    const int slow_rotation_light_threshold = 400; //if light_threshold-slow_rotation_light_threshold >= 400, robot slows rotation
    const int max_allowable_time = 9000; //maximum allowable time for this state.

    if (time1[T2] > max_allowable_time) {
        //point of no return - worst case state
        //if robot is rotating too long without seeing beacon, reset robot and re-locate strongest signal
        initialize_global_variables(); //reset global variables
        initialize_LED(); // reset signaling LEDs
        return AcquireStrongestSignal;
    }//if

    if (timeDiffLevelMeasured < (time_for_360_degrees / 2)) {
        //strongest signal was detected before robot completed 180 degrees
        if (diffLevelIRRight > light_threshold - slow_rotation_light_threshold) {
            //since robot is rotating to right, analyze right IR sensor
            //if right IR sensor is within 400 of threshold, slow rotation down
            motor[right] = -1 * slow_speed;
            motor[left] = slow_speed;
            //slow down spinning if robot sees it

            if (IRBeaconVisibleCombinedSensors()) {
                //if both sensors see the beacon, stop rotation and transition to approach beacon
                motor[left] = motor[right] = 0; //stop motors
                return Forward;
            }//if
        } /*if*/ else {
            if ( (diffLevelIRLeft < IR_threshold_facing_wall || diffLevelIRRight < IR_threshold_facing_wall)
                && SensorValue[ultrasonic] < ultrasonic_threshold_facing_wall && SensorValue[ultrasonic] > 0) {
                //if left and right IR values are below 1000, and if ultrasonic is less than 20 cm, robot is facing wall
                //speed up rotation to save time
                motor[right] = -1 * turn_speed_facing_wall;
                motor[left] = turn_speed_facing_wall;
            } /*if*/ else {
                //otherwise, maintain default rotation speed
                motor[right] = -1 * turnSpeed2;
                motor[left] = turnSpeed2;
            }//else
        }//else
    } /*if*/else {
        if (diffLevelIRLeft > light_threshold - slow_rotation_light_threshold) {
            //since robot is rotating to left, analyze left IR sensor
            //if left IR sensor is within 400 of threshold, slow rotation down
            motor[right] = slow_speed;
            motor[left] = -1 * slow_speed;
            //slow down spinning if robot sees it

            if (IRBeaconVisibleCombinedSensors()) {
                //if both sensors see the beacon, stop rotation and transition to approach beacon
                motor[left] = motor[right] = 0; //stop motors
                return Forward;
            }//if
        }/*if*/ else {
            if ( (diffLevelIRLeft < IR_threshold_facing_wall || diffLevelIRRight < IR_threshold_facing_wall)
                && SensorValue[ultrasonic] < ultrasonic_threshold_facing_wall && SensorValue[ultrasonic] > 0) {
                //if left and right IR values are below 1000, and if ultrasonic is less than 20 cm, robot is facing wall
                //speed up rotation to save time
                motor[right] = turn_speed_facing_wall;
                motor[left] = -1 * turn_speed_facing_wall;
            } /*if*/ else {
                //otherwise, maintain default rotation speed
                motor[right] = turnSpeed2;
                motor[left] = -1 * turnSpeed2;
            }//else
        }//else
    }//if
    return RotateToStrongestSignal;
} // end of RotateToStrongestSignalState

/**
 * Assesses if robot is close enough for cable connection.
 * Pre-conditions: none
 * Post-conditions: none
 *
 * @return      true, if distance is ok. false otherwise
 */
bool validate_connection_distance() {
    if ( SensorValue[ultrasonic] < ultrasonic_cable_connection_threshold &&
        (diffLevelIRLeft > IR_difference_cable_connection_threshold
         || diffLevelIRRight > IR_difference_cable_connection_threshold) ) {
        //either left or right IR has to have a max reading (they may not both have one since
        //the IR sensors only have around 20 degree field of view, and when
        //the robot is too close, only one of them may see the IR diodes in the beacon
        //ultraonic has to return a value close enough for connection as well
        return true;
    }//if
    return false;
}// validate_connection_distance

/**
 * Compensates for the variance in vex motor strength to ensure robot travels straight when
 * the same amount of power is sent to both motors.
 *
 * Pre-conditions: none
 * Post-conditions: motor values are modified to ensure robot trajectory is rectilinear
 *
 * @param speed     the power to assign the drive motors
 */
void drive_forward(int speed) {
    float correction = 0.91; //0.85 //percentage of power to assign right motor to ensure rectilinear motion
    motor[left] = speed;
    motor[right] = (int) ((float) speed * correction); //perform correction to right motor
}//drive_forward

/**
 * Compensates for the variance in vex motor strength to ensure robot travels straight when
 * the same amount of power is sent to both motors.
 *
 * Pre-conditions: both leftSpeed and rightSpeed are positive
 * Post-conditions: motor values are modified to ensure robot trajectory is rectilinear, and are above stall speed
 *
 * @param leftSpeed     the power to assign the left motor
 * @param rightSpeed    the power to assign the right motor
 */
void drive_forward(int leftSpeed, int rightSpeed) {
    float correction = 0.91; //0.85 //percentage of power to assign right motor to ensure rectilinear motion
    const int min_motor_speed = 25; //motor values below this may stall motor
    motor[left] = leftSpeed;
    rightSpeed = (int) ((float) rightSpeed * correction); // perform correction to right motor
    motor[right] = rightSpeed;
    if (rightSpeed < min_motor_speed && rightSpeed > 0) {
        //if the correction brought right motor speed below minimum speed, compensate left motor instead
        motor[left] = (int) (min_motor_speed / correction);
        motor[right] = min_motor_speed;
    }//if
}//drive_forward

/**
 * Scans 30 degrees on left and right of robot to ensure it is travelling in direction of
 * strongest IR signal.
 *
 * Failsafe: if it loses track of the signal, it will continue to spin until it finds it. If 5 seconds
 * have passed, and it has still not found the beacon direction, it likely lost where it is.
 * To prevent an infinite loop, it resets all global variables to initial state, and returns to AcquireStrongestSignal state.
 *
 * Pre-conditions: - global variables maxDiffLevelIRRight, maxDiffLevelIRLeft have been assigned values
 *                 - checkLeftDirection is true if left IR is stronger (so robot should rotate left, right, then left)
 *                 - checkLeftDirection is false if right IR is stronger (so robot default behaviour is right, left, right)
 * Post-conditions: - global variables maxDiffLevelIRRight, maxDiffLevelIRLeft are updated with the
 *                    appropriate values for the robot to use to find the beacon
 *                  - robot is facing toward direction of strongest signal
 *
 * @return      the next SystemState to transition to
 */
SystemStateType VerifyStrongestSignalState() {
    const int rotate_time = 500; //400 //first rotation time
    const int total_time = 1400; //1300 //total time to track IR values
    const int max_allowable_time = 5000; //3000 //max allowable time for this state
    const int threshold_variance = 150; //allowable variance between sensor values sensor value
    int VerifyStateTurnSpeed = 40; //35 //30 //initial rotation speed
    int VerifyStateTurnSpeedSlow = 35; //rotation speed when attempting to locate maximum IR values again

    if (checkLeftDirection) {
        //if checkLeftDirection is true, that meant when this state is called, the left IR was stronger
        //thus, robot rotates to left first
        //robot rotates in direction of stronger IR initially, since beacon is more likely to be in that direction
        VerifyStateTurnSpeed = -50; //-35 //-30
        VerifyStateTurnSpeedSlow = -35;
    }//if

    if (time1[T2] > max_allowable_time) {
        //point of no return - worst case state
        //if robot is rotating too far without seeing beacon, reset robot and re-locate strongest signal
        initialize_global_variables(); //reset global variables
        initialize_LED(); // reset signaling LEDs
        return AcquireStrongestSignal;
    } /*if*/ else if (time1[T2] > total_time) {
        //after total_time, robot has finished determining maximum values. It'll try to locate the maximums now
        light_threshold = (maxDiffLevelIRRight + maxDiffLevelIRLeft) / 2 - threshold_variance;
        //set light threshold to be average of the observed maximums, minus a allowable variance (to account for outliers)
        motor[right] = -1 * VerifyStateTurnSpeedSlow;
        motor[left] = VerifyStateTurnSpeedSlow;
        if (IRBeaconVisibleCombinedSensors()) {
            //if both sensors see the beacon, stop rotation and transition to approach beacon
            motor[left] = motor[right] = 0; //stop motors
            checkLeftDirection = false; //reset flag
            return Forward;
        }//if
    } /*if*/ else if (time1[T2] > rotate_time) {
        //second rotation to search for IR values. This is opposite direction to first rotation, to scan for 30 degrees from center
        //in that direction
        motor[right] = VerifyStateTurnSpeed;
        motor[left] = -1 * VerifyStateTurnSpeed;

        //if left or right IR values are higher than the maximum, remember it
        if (diffLevelIRRight > maxDiffLevelIRRight) {
            maxDiffLevelIRRight = diffLevelIRRight;
        }//if
        if (diffLevelIRLeft > maxDiffLevelIRLeft) {
            maxDiffLevelIRLeft = diffLevelIRLeft;
        }//if
    } /*if*/ else {
        //first rotation to search for IR values. It should rotate about 30 degrees to the right (default direction), or left
        // if it was determined that the left IR was stronger (and thus the beacon is more likely to be on the left)
        motor[right] = -1 * VerifyStateTurnSpeed;
        motor[left] = VerifyStateTurnSpeed;

        //if left or right IR values are higher than the maximum, remember it
        if (diffLevelIRRight > maxDiffLevelIRRight) {
            maxDiffLevelIRRight = diffLevelIRRight;
        }//if
        if (diffLevelIRLeft > maxDiffLevelIRLeft) {
            maxDiffLevelIRLeft = diffLevelIRLeft;
        }//if
    }//else
    return VerifyStrongestSignal;
}//end of VerifyStrongestSignal

/**
 * Drives robot forward toward IR signal. Compensates for differences in motor strengths and
 * corrects for deviations in the robot's trajectory by slowing down the side with the
 * stronger IR reading. Verifies the IR signal strength through transitioning to VerifyStrongestSignal state
 * every few seconds. If it detects an imminent collision with a wall, it moves to WallDetected state. If the
 * beacon was suddenly moved a large distance, it resets to acquire strongest signal state
 *
 * Pre-conditions: maximum IR values have been set by Acquire or Verify states
 * Post-conditions: motor values have been written to perform real world actuation
 *
 * @return      the next SystemState to transition to
 */
SystemStateType ForwardState() {
    const int min_motor_speed = 45; //35 //minimum motor speed when robot is far away
    const int base_speed = 30; //25 //used to calculate the motor speed
    const int k = 5; //4 2 //changes overall speed of robot, a coefficient in calculating motor speed
    const int divisor = 100; //used to calculate the motor speed
    const int target_IR_diff_value = 3750;//3600 3500 //used to calculate motor speed. this is the target IR value
    const int max_motor_speed = 95; //80 //max motor speed when robot is far away

    const int IR_variance_threshold = 300; //difference in left and right IR at which robot triggers VerifyStrongestSignal

    const int min_recheck_time = 1500;//1000 //minimum time elapsed before another VerifyStrongestSignal is called
    const int attachment_commitment_distance = 10;
    //when robot is closer than 8cm from object, it will no longer call VerifyStrongestSignal

    static int larger_diff_value = 0; //used in calculating motor speed

    if (diffLevelIRLeft > diffLevelIRRight) { //use the larger diff value to calculate motor speed
        larger_diff_value = diffLevelIRLeft;
    } /*if*/ else {
        larger_diff_value = diffLevelIRRight;
    }//else

    //calculate the ideal speed to travel at. It is faster when it is farther from beacon, and slows down as it gets
    //closer to beacon

    static int motorSpeed = 0;
    motorSpeed = base_speed + (target_IR_diff_value - larger_diff_value) / divisor * k;
    //motor speed is dependent on how far robot IR values are from the target IR values
    //robot travels extremely fast when it is far away, but slows down on approach
    if (motorSpeed < min_motor_speed) {
        //ensure that the motorSpeed is above stall speed
        motorSpeed = min_motor_speed;
    } /*if*/ else if (motorSpeed > max_motor_speed) {
        //ensure that the motorSpeed is within allowable maximum speeds
        motorSpeed = max_motor_speed;
    }//else if

    //if robot detects a wall, ultrasonic reads a small value but IR sensors are below the expected values
    //of the IR beacon at that distance
    if (SensorValue[ultrasonic] < ultrasonic_threshold && SensorValue[ultrasonic] >= 0 &&
        diffLevelIRLeft < 3400 && diffLevelIRRight < 3400) {
        //if wall detected, reset all variables and LEDs and move to wall detected state
        initialize_global_variables();
        initialize_LED();
        return WallDetected;
    }//if

    const float adjustment_percentage = 0.8; //percentage to slow down motor for trajectory adjustment
    const int variance = 30; //allowable variance between left and right IR values
    //corrects robot's trajectory by slowing down side with stronger signal.
    if (!(diffLevelIRLeft > 3800 || diffLevelIRRight > 3800) ){
        if (diffLevelIRLeft > diffLevelIRRight - variance) { //if left IR stronger, slow left motor down
            drive_forward((int)( motorSpeed * adjustment_percentage), motorSpeed);
        }/*if*/ else if (diffLevelIRRight > diffLevelIRLeft - variance) { //if right IR stronger, slow right motor down
            drive_forward( motorSpeed, (int) ( motorSpeed * adjustment_percentage));
        }/*if*/ else { //robot is straight. maintain set speed
            drive_forward(motorSpeed);
        }//else
    } else if (SensorValue[ultrasonic] > 15) { //IR values signal proximity to beacon, but robot is more than 15 cm away.
        //approach to beacon. Slow down for controlled approach
        drive_forward(35); //25
    } /*else if*/ else { //IR values signal proximity to beacon, and robot very close to beacon. Slow down robot even more
        drive_forward(25);
    }//else

    /*
     IF:    time has passed max_recheck time (2 seconds)
            ----since robot may be following wrong signal and should recheck itself once in a while even if the other conditions are satisfied
            OR left and right IR values differ by more than IR_variance_threshold (300) AND time has passed min_recheck time (1.5 seconds)
            ----since robot should not recheck its direction too often
            OR left and right IR values are below the set threshold  (set in AcquireStrongestSignal and VerifyStrongestSignal states, which is above background but lower than max values read), meaning beacon was moved
            ----IR values should slowly increase as robot nears beacon. It should never drop suddenly.
     If the above evaluates to true, it will switch to VerifyStrongestSignal state, but ONLY IF the robot is farther than attachment_commitment_distance, which is the distance in which the robot is committed to its direction of approach and will not attempt to correct its orientation
         ----when the robot is very close to the beacon, IR values between the left and right sensors begin to deviate significantly.
             This extra condition ensures the robot's approach to the beacon is controlled and smooth.
     */
    if ( (time1[T2] > max_recheck_time ||
               ( abs(diffLevelIRLeft - maxDiffLevelIRLeft - (diffLevelIRRight - maxDiffLevelIRRight) )
               > IR_variance_threshold && time1[T2] > min_recheck_time ) ||
               (diffLevelIRLeft < light_threshold - 250 && diffLevelIRRight < light_threshold - 250) ) &&
            SensorValue[ultrasonic] > attachment_commitment_distance) {
        maxDiffLevelIRLeft -= 100; //slightly lower the maximums to account for real-world discrepencies
        maxDiffLevelIRRight -= 100; //slightly lower the maximums to account for real-world discrepencies
        checkLeftDirection = diffLevelIRLeft > diffLevelIRRight; //if left IR is stronger, check towards the left first
        //otherwise, check to the right first

        if (time1[T2] > max_recheck_time) max_recheck_time += 1000;
        //robot shouldn't be forced to check itself too often (as it approaches the beacon,
        //it should be more confident that it isn't seeing a reflection)

        return VerifyStrongestSignal; //ture retures VerifyStrongestSignal
    }//if

    //if connection distance is reached, switch to Attach state
    if (validate_connection_distance()) {
        motor[left] = motor[right] = 0; //stop
        return Attach;
    }//if

    return Forward;
} // end of VerifyStrongestSignal

/**
 * When robot detected a wall, back up for 1 second, reset all global variables, and return to
 * AcquireStrongestSignal state to relocate beacon.
 *
 * Pre-conditions:  - robot is near a wall and IR values are lower than a beacon would emit
 * Post-conditions: - robot is away from a wall, and has reset all global variables
 *
 * @return      the next SystemState to transition to
 */
SystemStateType WallDetectedState() {
    const int backup_time = 1000; //duration of time to back up
    const int acceleration_time = backup_time / 2; //duration of time in which the robot is accelerating to max_speed
    const int base_speed = -25; //minimum speed, used to calculate robot's motorSpeed
    const int max_speed = -100; //maximum speed allowable
    const int k = -75; //constant, used to calculate robot's motorSpeed
    static int motorSpeed; //stores motor speed to write to motors

    if (time1[T2] < acceleration_time) {
        //accelerate for half the total time
        motorSpeed = base_speed + k * 1.0 * time1[T2] / acceleration_time;
    } /*if*/ else {
        motorSpeed = max_speed;
    }//else

    drive_forward(motorSpeed); //compensate for motor differences

    if (SensorValue(button1)) {
        //if it backs up into something
        drive_forward(50); //drive forward at 50 motor power for 500 ms
        clearTimer(T2);
        while (time1[T2] < 500) {
            //if while it is driving forward for 500 milliseconds, it is about to run into a wall, then it should back up
            if (SensorValue[ultrasonic] < ultrasonic_threshold && SensorValue[ultrasonic] >= 0) {
                initialize_global_variables(); //reset global variables
                initialize_LED();//clear LED indicators
                return WallDetected;
            }//if
        }//while
        //it is away from back wall now. revert to Acquire state
        return AcquireStrongestSignal;
    }//if
    if (time1[T2] > backup_time) {
        //if backup_time has elapsed
        motor[left] = motor[right] = 0; //stop
        sleep(200); //wait until robot has fully stopped

        return AcquireStrongestSignal;
    }//if
    return WallDetected;
}//end of WallDetectedState

/**
 * Lower attachment mechanism and then return Release state
 * Pre-conditions:  - Robot movement must have ceased
 * Post-conditions: - attachment mechanism is lowered
 *
 * @return      Release, the next SystemState to transition to
 */
SystemStateType AttachState() {
    motor[lift] = 40; //lower attachment mechanism

    if (SensorValue[ultrasonic] > ultrasonic_cable_connection_threshold +2) {// && !attach_success && time1[T2] % 500 <= 15) {
        //if robot for some reason stopped too early (this occured twice in our extensive testing)
        attach_success = false; //note that the attachment was not successful
    } /*if*/ else {
        attach_success = true;
    } /*else*/

    if (time1[T2] > 2600) {
        //if the amount of time has passed to lower the attachment mechanism
        if (!attach_success) {
            //if attachment was not successful since robot was too far away
            motor[lift] = -50; //reset lift position by powering lift motor to raise attachment mechanism
            sleep(2250);
            motor[lift] = 0;
            // go back to Forward state to properly approach beacon
            return Forward;
        }//if
        motor[lift] = 0; //stop motor

        return Release;
    }//if
    return Attach;
}//end of AttachState

/**
 * Back up and then raise attachment mechanism
 * Pre-conditions:  - attachment mechanism is lowered
 * Post-conditions: - Robot has stopped motion, lift is raised again (during testing only)
 *
 * @return      Idle, the next SystemState to transition to
 */
SystemStateType ReleaseState() {
    const int backup_time = 1000; //duration of time to back up
    const int acceleration_time = backup_time / 2; //duration of time in which the robot is accelerating to max_speed
    const int base_speed = -25; //minimum speed, used to calculate robot's motorSpeed
    const int max_speed = -100; //maximum speed allowable
    const int k = -75; //constant, used to calculate robot's motorSpeed
    static int motorSpeed; //stores motor speed to write to motors

    if (time1[T2] < acceleration_time) {
        //accelerate for half the total time
        motorSpeed = base_speed + k * 1.0 * time1[T2] / acceleration_time;
    } /*if*/ else {
        motorSpeed = max_speed;
    } //else

    drive_forward(motorSpeed);
    if (time1[T2] > backup_time || SensorValue(button1)) {
        //if backup_time has elapsed, or robot has backed into something, stop
        motor[left] = motor[right] = 0;
        sleep(500);

        motor[lift] = -50; //reset lift position by powering lift motor to raise attachment mechanism
        sleep(2250); //2300 //2320
        motor[lift] = 0;

        SensorValue[StateLEDCompletion] = 1; //signal task completion

        return Idle;
    }//if
    return Release;
}//end of ReleaseState

/**
 * Blinks all LEDs on the LED bar at 2 Hz
 * Pre-conditions:  - T3 timer is unused
 */
void blink_LED() {
    const int blink_time = 250; //time for half a period
    if (time1[T3] > blink_time * 2) {
        clearTimer(T3);
    } /*if*/ else if (time1[T3] > blink_time) {
        set_LED(0); //turn all LEDs off
    } /*else if*/ else {
        set_LED(1); //turn all LEDs on
    }//else
} //blink_LED

task main() {
    initialize_LED();

    SystemStateType SystemState = Idle; //Stores current state, default is start off at the Idle state
    SystemStateType NewState = Idle; //Stores next state, default next state initially is Idle
    while (true) {
        monitorLight();	//led strip
        switch (SystemState) {
            case Idle:
                initialize_motors(); //ensure robot has stopped moving
                initialize_global_variables(); //ensure global variables are initialized
                blink_LED(); //blink LED at 10 Hz

                if(SensorValue(button1)){ //if button one is pushed, start beacon search
                    initialize_LED(); //turn all LEDs off
                    NewState = AcquireStrongestSignal;
                    clearTimer(T2);
                }//if
                break;	//end of case
            case AcquireStrongestSignal:
                SensorValue[StateLEDAcquire] = 1;
                NewState = AcquireStrongestSignalState();
                break;	//end of case
            case RotateToStrongestSignal:
                SensorValue[StateLEDRotate] = 1;
                NewState = RotateToStrongestSignalState();
                break;	//end of case
            case Forward:
                SensorValue[StateLEDForward] = 1;
                NewState = ForwardState();
                break;	//end of case
            case VerifyStrongestSignal:
                SensorValue[StateLEDVerify] = 1;
                NewState = VerifyStrongestSignalState();
                break;	//end of case
            case Attach:
                SensorValue[StateLEDAttach] = 1;
                NewState = AttachState();
                break;	//end of case
            case Release:
                NewState = ReleaseState();
                break;	//end of case
            case WallDetected:
                NewState = WallDetectedState();
                break;	//end of case
            default:
                // should never go here
        } //end of switch
        if ( NewState != SystemState ) clearTimer(T2); // Reset timer when state changes.
        SystemState = NewState; // Set new state for next loop.
    } //end of while
}//end of main
