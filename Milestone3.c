#pragma config(I2C_Usage, I2C1, i2cSensors)
#pragma config(Sensor, in3,    IRsensorLeft,   sensorReflection)
#pragma config(Sensor, in4,    IRsensorRight,  sensorReflection)
#pragma config(Sensor, dgtl1,  button1,        sensorTouch)
#pragma config(Sensor, dgtl2,  ultrasonic,     sensorSONAR_inch)
#pragma config(Sensor, dgtl4,  StateLEDBeaconFound, sensorDigitalOut)
#pragma config(Sensor, dgtl7,  StateLEDDistanceOK, sensorDigitalOut)
#pragma config(Sensor, dgtl10, StateLEDDistanceTooFar, sensorDigitalOut)
#pragma config(Sensor, dgtl11, button2,        sensorTouch)
#pragma config(Sensor, dgtl12, limitSwitch,    sensorTouch)
#pragma config(Sensor, I2C_1,  ,               sensorQuadEncoderOnI2CPort,    , AutoAssign )
#pragma config(Motor,  port1,           steering,      tmotorVex393_HBridge, openLoop, encoderPort, I2C_1)
#pragma config(Motor,  port2,           lift,          tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port9,           left,          tmotorVex393_MC29, openLoop, reversed)
#pragma config(Motor,  port10,          right,         tmotorVex393_HBridge, openLoop)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

/**
 * Written by Robert Lee for use in the ENGR 120 Spring 2017 autonomous cable-running robot project.
 * Robert Lee, Calder Staude, Kyle Jarvis, Kyra Teetzen
 */

/* Timer use documentation:
 * T1: used for detecting 10Hz pulses from beacon. DO NOT USE OR MODIFY.
 * T2: unused
 * T3: unused
 * T4: unused
 */

bool beaconVisible;

typedef enum SystemStateType{
    FINDING_BEACON, //rotate to find beacon
    BEACON_FOUND, //beacon is found. signal with LED and stop rotating.
    Idle, //do nothing and scan for button input
    Forward, //go forward while watching out for walls
    WALL_DETECTED, //wall is detected. back up and turn away from it
    Center_Wheels //center the back wheel
} SystemStateType;

//threshold distance from wall that robot will tolerate
const int ultrasonic_threshold = 12; // threshold distance is 12 inches

//IR Thresholds. Higher values correlate to stronger signals, which are received
//when the robot is near the beacon. Two thresholds were hard coded for this milestone.
const int light_threshold = 1500; // 1200
//const int light_threshold_near = 2000; This threshold was used if robot was near the beacon

//higher difference levels mean more IR light is coming from that sensor's field of view.
int diffLevelIRRight = 0; // Delta between maximum and minimum seen in last 0.1 seconds
int diffLevelIRLeft = 0; // Delta between maximum and minimum seen in last 0.1 seconds

//keep track of previous difference levels
//used to average the past two diffLevels for the sensors, which should smooth out inconsistent signals
int prevdiffLevelIRRight = 0;
int prevdiffLevelIRLeft = 0;

// Perform processing of measurements.
// Should be called with rate of at least 20 Hertz for proper detection of puck.
bool monitorLight()
{
	static int minLevelIRRight = 4096;	// Minimum light level seen by right IR sensor
	static int maxLevelIRRight = 0;			// Maximum light level seen by right IR sensor

	static int minLevelIRLeft = 4096;	// Minimum light level seen by left IR sensor
	static int maxLevelIRLeft = 0;			// Maximum light level seen by left IR sensor

	int lightLevel1 = SensorValue[IRsensorRight];
	int lightLevel2 = SensorValue[IRsensorLeft];

	// Check if 100 msecs have elapsed.
	if ( time1[T1] > 100 )  {

		// 100 msecs have elapsed.  Compute delta of light level.

        prevdiffLevelIRRight = diffLevelIRRight; // used to average past two values to stabilize value
        prevdiffLevelIRLeft = diffLevelIRLeft; // used to average past two values
		diffLevelIRRight = maxLevelIRRight - minLevelIRRight;
		diffLevelIRLeft = maxLevelIRLeft - minLevelIRLeft;

		// Reset calculation for next 100 msecs.
		maxLevelIRRight = 0;
		minLevelIRRight = 4096;
		maxLevelIRLeft = 0;
		minLevelIRLeft = 4096;
		clearTimer(T1);

    } else {
		// Check for new minimum/maximum light levels.
		if ( lightLevel1 < minLevelIRRight ) {
			minLevelIRRight = lightLevel1;
        } else if ( lightLevel1 > maxLevelIRRight ) {
			maxLevelIRRight = lightLevel1;
		}/*else if*/
		if ( lightLevel2 < minLevelIRLeft ) {
			minLevelIRLeft = lightLevel2;
        }  else if ( lightLevel2 > maxLevelIRLeft ) {
			maxLevelIRLeft = lightLevel2;
		} /*else if*/
	}

	// Check if light level difference over threshold.
	return(diffLevelIRRight > light_threshold);
}

/**
 * Compares delta of light level for right IR to threshold
 * @return  Returns true if light level for right IR is over threshold
 */
bool IRsensorRightBeaconVisible() {
    return diffLevelIRRight > light_threshold;
}

/**
 * Compares delta of light level for left IR to threshold
 * @return  Returns true if light level for left IR is over threshold
 */
bool IRsensorLeftBeaconVisible() {
    return diffLevelIRLeft > light_threshold;
}

/**
 * Checks readings from left and right sensor to see if robot is centered between them
 * Reduces the chance of false positives from reflections on walls
 * @return      Returns true if the readings are within an allowable sensor variance
 */
bool IRBeaconVisibleCombinedSensors() {
    const int allowable_sensor_variance = 600;
    // allowable difference in values between left and right IR sensors when robot sees beacon

    if (IRsensorLeftBeaconVisible() && IRsensorRightBeaconVisible()) {
        //if both left and right beacons are over the threshold
        if (abs((diffLevelIRLeft + prevdiffLevelIRLeft)/2 -
        		(diffLevelIRRight + prevdiffLevelIRRight)/2 ) <= allowable_sensor_variance) {
            //Calculate the average light level delta for left and right IR sensors.
            //If the difference in left's average and the right's average is below the
            //allowable sensor variance, the robot sees the beacon
            return true;
        } /*if*/
    }/*if*/
    return false;
}

/**
 * Stops the robot and centers the back wheel to straight position
 */
void center_steering() {
	const int MIN_MOTOR_ENCODER = 120;
	const int MAX_MOTOR_ENCODER = 130;
    //adjusted to calibrate minimum and maximum motor encoder value for straight position
    //the range ensures that the motor does not oscillate if it overshoots

	static int turning_motor_speed = 75;
    //speed at which the wheel rotates

	motor[left] = motor[right] = 0; //stop the robot if it's going forward
	sleep(100); //wait a moment to ensure robot movement has ceased

	while (getMotorEncoder(steering) <= MIN_MOTOR_ENCODER || getMotorEncoder(steering) >= MAX_MOTOR_ENCODER) {
        //while the motor encoder value is not in the interval
        //MIN_MOTOR_ENCODER <= encoder value <= MAX_MOTOR_ENCODER, run code to correct it
		if (getMotorEncoder(steering) <= MIN_MOTOR_ENCODER) {
            // turn motor one direction if it's below minimum allowable encoder value
			motor[steering] = turning_motor_speed;

		} else if (getMotorEncoder(steering) >= MAX_MOTOR_ENCODER) {
            // turn motor other direction if it's above maximum allowable encoder value
			motor[steering] = -1 * turning_motor_speed;

		} /*else if*/
        //robot does not need to do anything until back wheel is oriented correctly
	} //while

	motor[steering] = 0; //once motor encoder satisfies these conditions, stop motor
} //center_steering()

/**
 * Stops the robot and rotates back wheel 90 degrees to prepare for point turn
 */
void rotate_back_motor_90_deg() {
    const int rotation_threshold = 470; // encoder value calibrated for 90 degree turn
    const int turning_motor_speed = 70; //speed at which the wheel rotates

    if (getMotorEncoder(steering) < rotation_threshold) {
        //if back wheel has not finished turning

        motor[right] = motor[left] = 0; //stop robot if it's moving
        sleep(100); //wait a moment to ensure robot movement has ceased

        motor[steering] = turning_motor_speed; //turn the motor in the right direction

        while (getMotorEncoder(steering) < rotation_threshold){
            // wait until back wheel has turned
            //robot does not need to do anything until back wheel is oriented correctly
        }//end of while

        motor[steering] = 0; //stop back wheel
    }//end of if
} // end of otate_back_motor_90_deg()

/**
 * Slowly rotates back wheel until it is in proper orientation, then resets Motor Encoder
 * value to 0
 * Button1 is used to signal that it is in the correct orientation
 */
void initialize_steering() {
	motor[steering] = -15; // provide a small amount of power to overcome resistance on back wheel motor and slowly rotate wheel with our help
	while(!SensorValue(button1)) {} // pressing the button stops the power and resets the encoder
	motor[steering] = 0; //stop the motor
	sleep(500); //wait to ensure motor movement has ceased before reseting MotorEncoder
	resetMotorEncoder(steering);
}//end of void initialize_steering()

/**
 * Rotates clockwise until it finds a signal strong enough to signal "beacon found"
 * Slows down when its right sensor is close to reaching threshold, accounting for moment of inertia
 * so robot does not overshoot the beacon
 * If the beacon is found, returns BEACON_FOUND state. Otherwise, maintains FINDING_BEACON state
 * @return      The appropriate Finite State Machine (FSM) state to switch to
 */
SystemStateType FindingBeaconState() {
    rotate_back_motor_90_deg(); //ensure back wheel is in correct orientatation for turning
    const int motor_speed = 30; // speed at which motor turns wheels
    const int motor_speed_slow = 25; //speed at which motor turns wheels when it sees a strong signal

    if (diffLevelIRRight > light_threshold - 200) {
        //if the right IR sensor is close to reaching threshold, slow down turn speed
        motor[left] = motor_speed_slow;
        motor[right] = -1 * motor_speed_slow;

        if (IRBeaconVisibleCombinedSensors()) {
            //if both IR sensors see beacon, stop and signal
            SensorValue[StateLEDBeaconFound] = 1; //signal that it sees beacon
            motor[left] = motor[right] = 0; //stop motors

            return BEACON_FOUND; //switch to BeaconFound FSM state
        }//if
    } else {
        //beacon is not visible. Keep turning.
        motor[left] = motor_speed;
        motor[right] = -1 * motor_speed;
    } //else
    //beacon is not seen
    return FINDING_BEACON; //maintain FindingBeacon FSM state
} //SystemStateType FindingBeaconState()

/**
 * Runs program which rotates the robot and identifies the IR beacon through comparing
 * the delta light levels received by its IR sensors. Stops robot when it sees the beacon.
 */
void run_beacon_search() {
    motor[left] = motor[right] = motor[steering] = 0; // initialize motors to 0

    SensorValue[StateLEDBeaconFound] = 0; // initialize LED indicator to OFF

    SystemStateType SystemState = Idle; // start state is Idle
    SystemStateType NewState = Idle; // Default next state is Idle

    while (true) {
    	beaconVisible = monitorLight(); //check IR values
        switch (SystemState) {
            case Idle:
                motor[left] = motor[right] = motor[steering] = 0; //ensure robot is not moving
                SensorValue[StateLEDBeaconFound] = 0; //ensures state LED is not on

                if(SensorValue(button1)) {
                    //if button1 is pushed, switch to FINDING_BEACON state
                    NewState = FINDING_BEACON;
              }//if
                break;
            case FINDING_BEACON:
                //rotate around to find beacon
                NewState = FindingBeaconState();
                break;
            case BEACON_FOUND:
                //beacon is found. Center back wheel to prepare for movement forwards
                NewState = Center_Wheels;
                break;
            case Center_Wheels:
                //call Center_steering() to center back wheel, then switch to Idle state
                center_steering();
                NewState = Idle;
                break;
            default:
                //should never happen
        }
        SystemState = NewState; // Set new state for next loop.
    }//end of switch
}	//end of run_beacon_search()

/**
 * Moves forward until it detects a wall. If the ultrasonic distance is below threshold, or
 * the limit switch is activated, return WALL_DETECTED state. Otherwise, maintain Forward state.
 * @return      The appropriate Finite State Machine (FSM) state to switch to
 */
SystemStateType ForwardState() {
    motor[left] = motor[right] = 100; // drive forward

    if(SensorValue[ultrasonic] > 0 && SensorValue[ultrasonic] <= ultrasonic_threshold){
        // if the robot is closer than the threshold distance, and reading is not a error (below 0)
        motor[right] = motor[left] = -50;
        sleep(500); // back up for a bit
        motor[right] = motor[left] = 0;
        sleep(25); // stop

        return WALL_DETECTED;
    }   else if(SensorValue[ultrasonic] > 0 && SensorValue[limitSwitch]){
        // ultrasonic is not an error, and limit switch is depressed, then it has contact wall
        motor[right] = motor[left] = -50;
        sleep(500); // back up for a bit
        motor[right] = motor[left] = 0;
        sleep(25); // stop

        return WALL_DETECTED;
    }/*else if*/
    return Forward;
} //SystemStateType ForwardState()

/**
 * Called when robot has detected a wall. On milestone 4 code, this would rotate the robot to
 * prevent another boundary collision.
 * @return      The appropriate Finite State Machine (FSM) state to switch to
 */
SystemStateType WallDetectedState() {
    const int buffer_time_after_turn = 250;
    // how long to keep turning after robot is no longer nearer than 18 inch, to ensure robot is
    // oriented at least parallel to wall so it will not collide with it when it moves forward
    const int buffer_wall_distance = 18; // how far away from wall robot must be before it rotates
    //ensures there is enough room for robot to rotate

    if(SensorValue[ultrasonic] > 0){ // not an error ultrasonic reading
        if (SensorValue[ultrasonic] <= buffer_wall_distance){
            // closer than ultrasonic_threshold buffer distance
            rotate_back_motor_90_deg(); //make sure back wheel is 90 degrees
            motor[left] = 50; //rotate robot
            motor[right] = -50;
        } else {//No longer pointing at wall

            sleep(buffer_time_after_turn);//keep turning for buffer_time, to ensure robot
            //is not going to collide with wall again
            return Center_Wheels; //move to center wheels state
        }/*else*/
    }/*if*/
    return WALL_DETECTED;//still closer than buffer_wall_distance. Keep turning.
}//end of SystemStateType WallDetectedState()

/**
 * Signals when your robot has made contact with a wall when turning or moving straight.
 * The robot moves forward until it sees the wall or its limit switch is triggered.
 * Backs robot up and turns until it is no longer facing a wall.
 */
void run_wall_detection() {
    motor[left] = motor[right] = motor[steering] = 0; // initialize motors to 0

    SensorValue[StateLEDBeaconFound] = 0; // initialize LED indicator to OFF

    SystemStateType SystemState = Idle; // start state is Idle
    SystemStateType NewState = Idle; // Default next state is Idle

    while (true) {
        switch (SystemState) {
            case Idle:
                motor[left] = motor[right] = motor[steering] = 0; //ensure robot is not moving

                if(SensorValue(button1)){
                    //button1 commences the behaviour
                    NewState = Forward;
                }//if
                break;
            case Forward:
                //move forward until it detects a wall. if so, stops and backs up
                NewState = ForwardState();
                break;
            case WALL_DETECTED:
                //turns until it no longer detects wall
                NewState = WallDetectedState();
                break;
            case Center_Wheels:
                //center back wheel after point turn, to be ready for forward motion
                center_steering();
                NewState = Idle;
                break;
            default:
                //should never happen
        }//switch
        SystemState = NewState; // Set new state for next loop.
    }//while
}//run_wall_detection()

// Thresholds that will trigger "robot is close enough to beacon" LED. Change these to calibrate.
const int ultrasonic_cable_connection_threshold = 3;
//threshold for sonar in inches that triggers "distance is ok" LED
const int IR_difference_cable_connection_threshold = 3500; // max that is possible is around 3900
//threshold for IR difference levels that triggers "distance is ok" LED


/**
 * Function works for distances up to 1 meter from target. Greater than that, behaviour is not guaranteed.
 * Signals when robot is properly facing the target object for approach but is too far
 * away for cable connection.
 * Signals when robot is at the proper distance and orientation for cable connection.
 */
void run_distance_estimation() {
    motor[left] = motor[right] = motor[steering] = 0; // initialize motors to 0

    SensorValue[StateLEDDistanceTooFar] = 0;
    SensorValue[StateLEDDistanceOK] = 0; // initialize LED indicator to OFF

    while (true) {
        monitorLight();
        if ( SensorValue[ultrasonic] < ultrasonic_cable_connection_threshold &&
            (diffLevelIRLeft > IR_difference_cable_connection_threshold
             || diffLevelIRRight > IR_difference_cable_connection_threshold) ) {
                //if robot is close to an object, and its IR values are high, it must be
                //next to the beacon.
                //Either IR sensor has to have a max reading (they may not both have one since
                //the IR sensors only have around 20 degree field of view, and when
                //the robot is too close, only one of them may see the IR emitters on the beacon

                //signal appropriate LED
                SensorValue[StateLEDDistanceTooFar] = 0;
                SensorValue[StateLEDDistanceOK] = 1;
        }  else if (IRBeaconVisibleCombinedSensors()) {
                //Beacon is visible, but robot is too far
                //signal appropriate LED
                SensorValue[StateLEDDistanceTooFar] = 1;
                SensorValue[StateLEDDistanceOK] = 0;
        } else {
                //Robot does not see beacon.
                //signal appropriate LED
                SensorValue[StateLEDDistanceTooFar] = 0;
                SensorValue[StateLEDDistanceOK] = 0;
        }/*else*/
    }//while
}//run_distance_estimation()

///////////////////////////MAIN/////////////////////
task main(){
	initialize_steering(); // power the back wheel to center it
    run_beacon_search();
//	run_wall_detection();								//the functions will be called depending on the test the robot needs to perform
//	run_distance_estimation();					//the functions will be called depending on the test the robot needs to perform
}// end main
