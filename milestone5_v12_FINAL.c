#pragma config(Sensor, in1,    IRsensorFRight, sensorReflection)
#pragma config(Sensor, in2,    IRsensorFCornerLeft, sensorReflection)
#pragma config(Sensor, in3,    IRsensorFLeft,  sensorReflection)
#pragma config(Sensor, in4,    IRsensorFCornerRight, sensorReflection)
#pragma config(Sensor, in5,    IRsensorSRight, sensorReflection)
#pragma config(Sensor, in6,    IRsensorSLeft,  sensorReflection)
#pragma config(Sensor, in7,    IRsensorFShortRight, sensorReflection)
#pragma config(Sensor, in8,    IRsensorFShortLeft, sensorReflection)
#pragma config(Sensor, dgtl1,  button1,        sensorTouch)
#pragma config(Sensor, dgtl2,  StateLEDAcquire, sensorDigitalOut)
#pragma config(Sensor, dgtl3,  StateLEDRotate, sensorDigitalOut)
#pragma config(Sensor, dgtl4,  StateLEDForward, sensorDigitalOut)
#pragma config(Sensor, dgtl5,  StateLEDVerify, sensorDigitalOut)
#pragma config(Sensor, dgtl6,  StateLEDAttach, sensorDigitalOut)
#pragma config(Sensor, dgtl7,  StateLEDCompletion, sensorDigitalOut)
#pragma config(Sensor, dgtl9,  switchRight,    sensorTouch)
#pragma config(Sensor, dgtl10, switchLeft,     sensorTouch)
#pragma config(Sensor, dgtl11, ultrasonic,     sensorSONAR_cm)
#pragma config(Motor,  port1,           left,          tmotorVex393_HBridge, openLoop)
#pragma config(Motor,  port2,           lift,          tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port10,          right,         tmotorVex393_HBridge, openLoop)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

/**
 * Written by Robert Lee for use in the ENGR 120 Spring 2017 autonomous cable-running robot project.
 */

/* Timer use documentation:
 * T1: used for detecting 10Hz pulses from beacon. DO NOT USE.
 * T2: used for timing find beacon state.
 * T3: used for LED blinking
 * T4:
 *
 */

typedef enum SystemStateType{
    Idle, //stop all motors, initialize global variables
    AcquireStrongestSignal, //spin 360 degrees and track max values received by IR sensors
    RotateToStrongestSignal, //spin in most efficient direction to rotate to the max value
    Forward, //drive to the beacon while calculating if it is off course. Small corrections to trajectory
    VerifyStrongestSignal, //check if robot direction is correct. If not, perform large corrections to trajectory
    Attach, //lower attachment mechanism
    Release, //back up robot and signal task completion
    WallDetected //backs up robot 1 second. Called when robot encounters a wall
} SystemStateType; //used as Finite State Machine state variable

const int ultrasonic_threshold = 14; //threshold distance to trigger wall detection algorithm is 14 inches

const int time_for_360_degrees = 3900; //time robot takes to rotate 360 degrees
const int turnSpeed = 60; //speed at which robot rotates

int light_threshold = 1000; //initial light threshold value.
int diffLevelIR_FRight = 0; // Delta between maximum and minimum seen in last 0.1 seconds
int diffLevelIR_FLeft = 0; // Delta between maximum and minimum seen in last 0.1 seconds

int diffLevelIR_FShortLeft = 0; // Delta between maximum and minimum seen in last 0.1 seconds
int diffLevelIR_FShortRight = 0; // Delta between maximum and minimum seen in last 0.1 seconds
int diffLevelIR_FCornerRight = 0; // Delta between maximum and minimum seen in last 0.1 seconds
int diffLevelIR_FCornerLeft = 0; // Delta between maximum and minimum seen in last 0.1 seconds
int diffLevelIR_SRight = 0; // Delta between maximum and minimum seen in last 0.1 seconds
int diffLevelIR_SLeft = 0; // Delta between maximum and minimum seen in last 0.1 seconds


int maxDiffIR_FRight = 0; //keeps track of highest IR value seen by right IR
int timeDiffLevelMeasured = 0; //tracks time at which this maximum was seen

int maxDiffIR_FLeft = 0; //keeps track of highest IR value seen by left IR
int maxDiffIR_FShortLeft = 0;
int maxDiffIR_FShortRight = 0;
int maxDiffIR_peripheral = 0;
const int time_to_reset = 4000;

int max_recheck_time = 2000; //if this amount of time has passed, transition from Forward to VerifyStrongestSignal

bool checkLeftDirection = false;
bool closeDistance = false;
//if true, robot rotates left, right, left when in VerifyStrongestSignal state
//if false, robot rotates right, left, right when in VerifyStrongestSignal state

const int ultrasonic_cable_connection_threshold = 5; //threshold for sonar in cm that triggers attachment process
const int IR_difference_cable_connection_threshold = 3500; // max that is possible is around 3900
//threshold for IR difference levels that triggers attachment process

void set_LED(int value) {
    //set all LED lights to the given on/off value
    SensorValue[StateLEDAcquire] = SensorValue[StateLEDRotate] = SensorValue[StateLEDForward] = value;
    SensorValue[StateLEDVerify] = SensorValue[StateLEDAttach] = SensorValue[StateLEDCompletion] = value;
}

void initialize_LED() {
    set_LED(0); //set all LEDs to off
}

void initialize_motors() {
    motor[left] = motor[right] = motor[lift] = 0; //set all motors to stopped
}

void initialize_global_variables() {
    //reset all global variables to initial state
    light_threshold = 1000;

    maxDiffIR_FRight = 0;
    timeDiffLevelMeasured = 0;

    maxDiffIR_FLeft = 0;

    maxDiffIR_peripheral = 0;
    maxDiffIR_FShortLeft = 0;
    maxDiffIR_FShortRight = 0;

    checkLeftDirection = false;
    closeDistance = false;
    max_recheck_time = 2000;
}

// Perform processing of measurements.
// Should be called with rate of at least 20 Hertz for proper detection of puck.
void monitorLight()
{
    static int minLevelIR_FRight = 4096;	// Minimum light level seen by front right IR sensor
    static int maxLevelIR_FRight = 0;			// Maximum light level seen by front right IR sensor

    static int minLevelIR_FLeft = 4096;	// Minimum light level seen by front left IR sensor
    static int maxLevelIR_FLeft = 0;			// Maximum light level seen by front left IR sensor

    static int minLevelIR_FShortLeft = 4096;	// Minimum light level seen by front center IR sensor
    static int maxLevelIR_FShortLeft = 0;			// Maximum light level seen by front center IR sensor

    static int minLevelIR_FCornerRight = 4096;	// Minimum light level seen by front center IR sensor
    static int maxLevelIR_FCornerRight = 0;			// Maximum light level seen by front center IR sensor

    static int minLevelIR_FCornerLeft = 4096;	// Minimum light level seen by front center IR sensor
    static int maxLevelIR_FCornerLeft = 0;			// Maximum light level seen by front center IR sensor

    static int minLevelIR_SLeft = 4096;	// Minimum light level seen by front center IR sensor
    static int maxLevelIR_SLeft = 0;			// Maximum light level seen by front center IR sensor

    static int minLevelIR_SRight = 4096;	// Minimum light level seen by front center IR sensor
    static int maxLevelIR_SRight = 0;			// Maximum light level seen by front center IR sensor

    static int minLevelIR_FShortRight = 4096;	// Minimum light level seen by front center IR sensor
    static int maxLevelIR_FShortRight = 0;			// Maximum light level seen by front center IR sensor

    int lightLevel_FRight = SensorValue[IRsensorFRight];
    int lightLevel_FLeft = SensorValue[IRsensorFLeft];
    int lightLevel_FShortLeft = SensorValue[IRsensorFShortLeft];
    int lightLevel_FCornerRight = SensorValue[IRsensorFCornerRight];
    int lightLevel_FCornerLeft = SensorValue[IRsensorFCornerLeft];
    int lightLevel_SLeft = SensorValue[IRsensorSLeft];
    int lightLevel_SRight = SensorValue[IRsensorSRight];
    int lightLevel_FShortRight = SensorValue[IRsensorFShortRight];

    // Check if 100 msecs have elapsed.
    if ( time1[T1] > 100 )  {

        // 100 msecs have elapsed.  Compute delta of light level.

        //prevdiffLevelIR_FRight = diffLevelIR_FRight; // used to average past two values to stabilize value
        //prevdiffLevelIR_FLeft = diffLevelIR_FLeft; // used to average past two values
        diffLevelIR_FRight = maxLevelIR_FRight - minLevelIR_FRight;
        diffLevelIR_FLeft = maxLevelIR_FLeft - minLevelIR_FLeft;
        diffLevelIR_FShortLeft = maxLevelIR_FShortLeft - minLevelIR_FShortLeft;
        diffLevelIR_SRight = maxLevelIR_SRight - minLevelIR_SRight;
        diffLevelIR_SLeft = maxLevelIR_SLeft - minLevelIR_SLeft;
        diffLevelIR_FShortRight = maxLevelIR_FShortRight - minLevelIR_FShortRight;
        diffLevelIR_FCornerRight = maxLevelIR_FCornerRight - minLevelIR_FCornerRight;
        diffLevelIR_FCornerLeft = maxLevelIR_FCornerLeft - minLevelIR_FCornerLeft;

        // Reset calculation for next 100 msecs.
        maxLevelIR_FRight = 0;
        minLevelIR_FRight = 4096;
        maxLevelIR_FLeft = 0;
        minLevelIR_FLeft = 4096;
        maxLevelIR_FShortLeft = 0;
        minLevelIR_FShortLeft = 4096;
        maxLevelIR_FCornerRight = 0;
        minLevelIR_FCornerRight = 4096;
        maxLevelIR_FCornerLeft = 0;
        minLevelIR_FCornerLeft = 4096;
        maxLevelIR_SLeft = 0;
        minLevelIR_SLeft = 4096;
        maxLevelIR_SRight = 0;
        minLevelIR_SRight = 4096;
        maxLevelIR_FShortRight = 0;
        minLevelIR_FShortRight = 4096;


        clearTimer(T1);

    } else {

        // Check for new minimum/maximum light levels.
        if ( lightLevel_FRight < minLevelIR_FRight ) {
            minLevelIR_FRight = lightLevel_FRight;
        } else if ( lightLevel_FRight > maxLevelIR_FRight ) {
            maxLevelIR_FRight = lightLevel_FRight;
        }
        if ( lightLevel_FLeft < minLevelIR_FLeft ) {
            minLevelIR_FLeft = lightLevel_FLeft;
        } else if ( lightLevel_FLeft > maxLevelIR_FLeft ) {
            maxLevelIR_FLeft = lightLevel_FLeft;
        }
        if ( lightLevel_FShortLeft < minLevelIR_FShortLeft) {
            minLevelIR_FShortLeft = lightLevel_FShortLeft;
        } else if ( lightLevel_FShortLeft > maxLevelIR_FShortLeft ) {
            maxLevelIR_FShortLeft = lightLevel_FShortLeft;
        }
        if ( lightLevel_FCornerRight < minLevelIR_FCornerRight ) {
            minLevelIR_FCornerRight = lightLevel_FCornerRight;
        } else if ( lightLevel_FCornerRight > maxLevelIR_FCornerRight ) {
            maxLevelIR_FCornerRight = lightLevel_FCornerRight;
        }
        if ( lightLevel_FCornerLeft < minLevelIR_FCornerLeft ) {
            minLevelIR_FCornerLeft = lightLevel_FCornerLeft;
        } else if ( lightLevel_FCornerLeft > maxLevelIR_FCornerLeft ) {
            maxLevelIR_FCornerLeft = lightLevel_FCornerLeft;
        }
        if ( lightLevel_SLeft < minLevelIR_SLeft ) {
            minLevelIR_SLeft = lightLevel_SLeft;
        } else if ( lightLevel_SLeft > maxLevelIR_SLeft ) {
            maxLevelIR_SLeft = lightLevel_SLeft;
        }
        if ( lightLevel_SRight < minLevelIR_SRight ) {
            minLevelIR_SRight = lightLevel_SRight;
        } else if ( lightLevel_SRight > maxLevelIR_SRight ) {
            maxLevelIR_SRight = lightLevel_SRight;
        }
        if ( lightLevel_FShortRight < minLevelIR_FShortRight ) {
            minLevelIR_FShortRight = lightLevel_FShortRight;
        } else if ( lightLevel_FShortRight > maxLevelIR_FShortRight ) {
            maxLevelIR_FShortRight = lightLevel_FShortRight;
        }
    }
}

/**
 * Corroborates left and right IR values to verify if IR signal is coming from a beacon
 *
 * Pre-conditions: global variables maxDiffIR_FRight, maxDiffIR_FLeft have been set by VerifyStrongestSignal or AcquireStrongestSignal
 *
 * @return      if the sensor readings match the expected signal from the beacon
 */
bool IRBeaconVisibleCombinedSensorsOLD() {
    const int allowable_sensor_variance = 200;
    // allowable difference between left and right IR sensors when robot sees beacon

    if (diffLevelIR_FLeft > maxDiffIR_FLeft - allowable_sensor_variance &&
        diffLevelIR_FRight > maxDiffIR_FRight - allowable_sensor_variance) {
        //If both left and right IR values are within a allowable variance with the maximum, robot has seen beacon
        return true;
    }

    return false;
}

bool IRBeaconVisibleCombinedSensors() {
    const int allowable_sensor_variance = 200;
    const int variance_from_max = 250; //300
    const int variance_corner = 100;
    const int short_threshold = 3500;

    // allowable difference between left and right IR sensors when robot sees beacon

    //if (diffLevelIR_FShortLeft > diffLevelIR_FLeft && diffLevelIR_FShortLeft > diffLevelIR_FRight) {
        if (abs(diffLevelIR_FLeft - diffLevelIR_FRight) > allowable_sensor_variance &&
            diffLevelIR_FRight > maxDiffIR_FRight - variance_from_max &&
            diffLevelIR_FLeft > maxDiffIR_FLeft - variance_from_max &&
            diffLevelIR_FRight > diffLevelIR_FCornerRight - variance_corner &&
            diffLevelIR_FRight > diffLevelIR_FCornerLeft - variance_corner &&
            diffLevelIR_FLeft > diffLevelIR_FCornerRight - variance_corner &&
            diffLevelIR_FLeft > diffLevelIR_FCornerLeft - variance_corner) {
            //If both left and right IR values are within a allowable variance with the maximum, robot has seen beacon
            if (maxDiffIR_FLeft > short_threshold || maxDiffIR_FRight > short_threshold) {
                if (diffLevelIR_FShortLeft > 0 && diffLevelIR_SRight > 0) {
                    return true;
                }
            } else {
                return true;
            }
        }
    //}

    return false;
}

SystemStateType AcquireStrongestSignalState() {
    const int rotation_threshold = 70;
    int frontdiff = diffLevelIR_FLeft - diffLevelIR_FRight;
    int sidediff = diffLevelIR_SLeft - diffLevelIR_SRight;
    int frontcornerdiff = diffLevelIR_FCornerLeft - diffLevelIR_FCornerRight;

    int largestFrontDiff = 0;
    int largestFCornerDiff = 0;
    int largestSideDiff = 0;

    if (diffLevelIR_FLeft > diffLevelIR_FRight) {
        largestFrontDiff = diffLevelIR_FLeft;
    } else {
        largestFrontDiff = diffLevelIR_FRight;
    }

    if (diffLevelIR_FCornerLeft > diffLevelIR_FCornerRight) {
        largestFCornerDiff = diffLevelIR_FCornerLeft;
    } else {
        largestFCornerDiff = diffLevelIR_FCornerRight;
    }

    if (diffLevelIR_SLeft > diffLevelIR_SRight) {
        largestSideDiff = diffLevelIR_SLeft;
    } else {
        largestSideDiff = diffLevelIR_SRight;
    }

    if (largestFrontDiff > largestSideDiff && largestFrontDiff > largestFCornerDiff) {
        checkLeftDirection = frontdiff > 0;
    } else if (largestFCornerDiff > largestSideDiff && largestFCornerDiff > largestFrontDiff) {
        checkLeftDirection = frontcornerdiff > 0;
    } else {
        checkLeftDirection = sidediff > 0;
    }


    if (diffLevelIR_SRight > maxDiffIR_peripheral) maxDiffIR_peripheral = diffLevelIR_SRight;
    if (diffLevelIR_SLeft > maxDiffIR_peripheral) maxDiffIR_peripheral = diffLevelIR_SLeft;
    if (diffLevelIR_FShortRight > maxDiffIR_peripheral) maxDiffIR_peripheral = diffLevelIR_FShortRight;
    if (diffLevelIR_FShortLeft > maxDiffIR_peripheral) maxDiffIR_peripheral = diffLevelIR_FShortLeft;

    clearTimer(T2);
    return RotateToStrongestSignal;
}

SystemStateType RotateToStrongestSignalState() {
    int turnSpeedXFast  = 100; //90
    int turnSpeedFast   = 80; //70
    int turnSpeedMedium = 55; //50
    int turnSpeedSlow   = 40; //45
    const int threshold_variance = 250;//400;//250
    const int peripheral_threshold_variance = 350;//250
    const int IR_threshold_facing_wall = 1000; //if an object is to be considered a wall, left and right IR must be below this threshold
    const int ultrasonic_threshold_facing_wall = 20; //if an object is to be considered a wall, ultrasonic must be below this threshold

    if (checkLeftDirection) {
        //if checkLeftDirection is true, that meant when this state is called, the left IR was stronger
        //thus, robot rotates to left first
        //robot rotates in direction of stronger IR initially, since beacon is more likely to be in that direction
        turnSpeedXFast  = -100; //90
        turnSpeedFast   = -80; //70
        turnSpeedMedium = -55; //50
        turnSpeedSlow   = -40; //-45
    }

    if (time1[T2] >= time_to_reset) {
    	  initialize_global_variables();
    	  initialize_LED();
    	  initialize_motors();
    	  clearTimer(T2);
    	  return AcquireStrongestSignal;
  }

    if (diffLevelIR_FRight > maxDiffIR_FRight)              maxDiffIR_FRight = diffLevelIR_FRight;
    if (diffLevelIR_FLeft > maxDiffIR_FLeft)                maxDiffIR_FLeft = diffLevelIR_FLeft;
    if (diffLevelIR_FShortLeft > maxDiffIR_FShortLeft)      maxDiffIR_FShortLeft = diffLevelIR_FShortLeft;
    if (diffLevelIR_FShortRight > maxDiffIR_FShortRight)    maxDiffIR_FShortRight = diffLevelIR_FShortRight;
    if (diffLevelIR_FCornerLeft > maxDiffIR_peripheral)     maxDiffIR_peripheral = diffLevelIR_FCornerLeft;
    if (diffLevelIR_FCornerRight > maxDiffIR_peripheral)    maxDiffIR_peripheral = diffLevelIR_FCornerRight;
    if (diffLevelIR_SRight > maxDiffIR_peripheral)          maxDiffIR_peripheral = diffLevelIR_SRight;
    if (diffLevelIR_SLeft > maxDiffIR_peripheral)           maxDiffIR_peripheral = diffLevelIR_SLeft;

    if (maxDiffIR_FLeft > light_threshold + threshold_variance)
        light_threshold = maxDiffIR_FLeft - threshold_variance;
    if (maxDiffIR_FRight > light_threshold + threshold_variance)
        light_threshold = maxDiffIR_FRight - threshold_variance;
    if (maxDiffIR_peripheral > light_threshold + peripheral_threshold_variance)
        light_threshold = maxDiffIR_peripheral - peripheral_threshold_variance;

    if (diffLevelIR_FCornerRight > light_threshold || diffLevelIR_FCornerLeft > light_threshold ||
        diffLevelIR_FRight > light_threshold || diffLevelIR_FLeft > light_threshold) {

        motor[right] = -1 * turnSpeedMedium;
        motor[left] = turnSpeedMedium;
        if (diffLevelIR_FRight > light_threshold || diffLevelIR_FLeft > light_threshold) {
            motor[right] = -1 * turnSpeedSlow;
            motor[left] = turnSpeedSlow;

            if (IRBeaconVisibleCombinedSensors()) {
                //if both sensors see the beacon, stop rotation and transition to approach beacon
                motor[left] = motor[right] = 0; //stop motors
                checkLeftDirection = false;
                sleep(100);

                clearTimer(T2);
                return Forward;
            }
        }
    } else {
        if ( (diffLevelIR_FLeft < IR_threshold_facing_wall || diffLevelIR_FRight < IR_threshold_facing_wall)
            && SensorValue[ultrasonic] < ultrasonic_threshold_facing_wall && SensorValue[ultrasonic] > 0) {
            //if left and right IR values are below 1000, and if ultrasonic is less than 20 cm, robot is facing wall
            //speed up rotation to save time
            motor[right] = -1 * turnSpeedXFast;
            motor[left] = turnSpeedXFast;
        } else {
            //otherwise, maintain default rotation speed
            motor[right] = -1 * turnSpeedFast;
            motor[left] = turnSpeedFast;
        }
    }

    return RotateToStrongestSignal;
}


/**
 * Assesses if robot is close enough for cable connection.
 * Pre-conditions:
 * Post-conditions:
 *
 * @return      true, if distance is ok. false otherwise
 */
bool validate_connection_distance() {
    if ( SensorValue[ultrasonic] < ultrasonic_cable_connection_threshold &&
    		 SensorValue[ultrasonic] > 0 &&
        (diffLevelIR_FLeft > IR_difference_cable_connection_threshold
         || diffLevelIR_FRight > IR_difference_cable_connection_threshold) ) {
        //either one has to have a max reading (they may not both have one since
        //the IR sensors only have around 20 degree field of view, and when
        //the robot is too close, only one of them may see the IR emitters
        return true;
    }
    return false;
}

/**
 * Compensates for the variance in vex motor strength to ensure robot travels straight when
 * the same amount of power is sent to both motors.

 * Pre-conditions:
 * Post-conditions:
 *
 * @param speed     the power to assign the drive motors
 */
void drive_forward(int speed) {
    float correction = 1;//0.91; //0.85
		//float correction = 1;
    motor[right] = speed;
    motor[left] = speed; //(int) ((float) speed * correction);
}

/**
 * Compensates for the variance in vex motor strength to ensure robot travels straight when
 * the same amount of power is sent to both motors.

 * Pre-conditions:
 * Post-conditions:
 *
 * @param leftSpeed     the power to assign the left motor
 * @param rightSpeed    the power to assign the right motor
 */
void drive_forward(int leftSpeed, int rightSpeed) {
    //float correction = 1;//0.91; //0.85
    //float correction = 1;
    //const int min_motor_speed = 25;
    motor[right] = rightSpeed;
    //leftSpeed = (int) ((float) leftSpeed * correction);
    motor[left] = leftSpeed;
    //if (leftSpeed < min_motor_speed && leftSpeed > 0) {
    //    motor[right] = (int) (min_motor_speed / correction);
    //    motor[left] = min_motor_speed;
    //}
}

SystemStateType ForwardState() {
    const int motorSpeedFast = 127;
    const int switchOverIRThreshold = 3000;

    const int attachment_commitment_distance = 8;
    const int slowDownDistance = 15;

    const float adjustment_percentage = 0.6; //slow down the motor to this percentage
    const float adjustment_percentage_small = 0.8;
    const int variance = 50;//50

    const int min_motor_speed = 30; //35 //minimum motor speed when robot is far away
    const int base_speed = 30; //25 //used to calculate the motor speed
    const float k = 3.5; //3.3 //4 2 //changes overall speed of robot, a coefficient in calculating motor speed
    const int target_ultrasonic_value = 20; //8 //3600 3500 //used to calculate motor speed
    const int max_motor_speed = 127; //80 //max motor speed when robot is far away
    //const int max_motor_speed_approach = 60;

    static int motorSpeed = 0;
    //motorSpeed = (target_IR_diff_value - larger_diff_value) / divisor * k;
    motorSpeed = base_speed + (SensorValue[ultrasonic] - target_ultrasonic_value) * k;
    if (motorSpeed < min_motor_speed ||
        (SensorValue[ultrasonic] < attachment_commitment_distance && SensorValue[ultrasonic] >= 0)) {
        //|| target_IR_diff_value < larger_diff_value) {
        motorSpeed = min_motor_speed;
    } else if (motorSpeed > max_motor_speed) {
        motorSpeed = max_motor_speed;
    }

    if (diffLevelIR_FLeft > switchOverIRThreshold || diffLevelIR_FRight > switchOverIRThreshold) {

        if ((SensorValue[ultrasonic] < slowDownDistance && SensorValue[ultrasonic] >= 0) ||
        	  diffLevelIR_FShortLeft > 3800 || diffLevelIR_FShortRight > 3800) {
            if (diffLevelIR_FLeft - diffLevelIR_FRight > variance*2) { //if left IR stronger, slow left motor down
                drive_forward((int)( motorSpeed * adjustment_percentage_small), motorSpeed);
            } else if (diffLevelIR_FRight - diffLevelIR_FLeft > variance*2) { //if right IR stronger, slow right motor down
                //drive_forward( motorSpeed, (int) ( motorSpeed * adjustment_percentage));
                drive_forward(motorSpeed, (int) motorSpeed * adjustment_percentage_small);
            } else { //robot is straight. maintain set speed
                drive_forward(motorSpeed);
            }
        } else if (diffLevelIR_FShortLeft - diffLevelIR_FShortRight > variance) { //if left IR stronger, slow left motor down
            drive_forward((int)( motorSpeed * adjustment_percentage), motorSpeed);
        } else if (diffLevelIR_FShortRight - diffLevelIR_FShortLeft > variance) { //if right IR stronger, slow right motor down
            //drive_forward( motorSpeed, (int) ( motorSpeed * adjustment_percentage));
            drive_forward((int) ( motorSpeed / adjustment_percentage), motorSpeed);
        } else { //robot is straight. maintain set speed
            drive_forward(motorSpeed);
        }
    } else {
    		if ((SensorValue[ultrasonic] < attachment_commitment_distance && SensorValue[ultrasonic] >= 0) ||
        	  diffLevelIR_FShortLeft > 3850 || diffLevelIR_FShortRight > 3850) {
        	  	const int variance2 = 70;
            if (diffLevelIR_FLeft - diffLevelIR_FRight > variance2) { //if left IR stronger, slow left motor down
                drive_forward((int)( motorSpeed * adjustment_percentage_small), motorSpeed);
            } else if (diffLevelIR_FRight - diffLevelIR_FLeft > variance2) { //if right IR stronger, slow right motor down
                //drive_forward( motorSpeed, (int) ( motorSpeed * adjustment_percentage));
                drive_forward(motorSpeed, (int) motorSpeed * adjustment_percentage_small);
            } else { //robot is straight. maintain set speed
                drive_forward(motorSpeed);
            }
        } else if (diffLevelIR_FLeft - diffLevelIR_FRight > variance) { //if left IR stronger, slow left motor down
            drive_forward((int)( motorSpeedFast * adjustment_percentage_small), motorSpeedFast);
        } else if (diffLevelIR_FRight - diffLevelIR_FLeft > variance) { //if right IR stronger, slow right motor down
            //drive_forward( motorSpeed, (int) ( motorSpeed * adjustment_percentage));
            drive_forward(motorSpeedFast, (int) motorSpeedFast * adjustment_percentage_small);
        } else { //robot is straight. maintain set speed
            drive_forward(motorSpeedFast);
        }
    }

    if (SensorValue[ultrasonic] < ultrasonic_threshold && SensorValue[ultrasonic] >= 0 &&
        diffLevelIR_FLeft < 3400 && diffLevelIR_FRight < 3400) {
        initialize_global_variables();
        initialize_LED();
        clearTimer(T2);
        return WallDetected;
    }

    if (validate_connection_distance()) {
        motor[left] = motor[right] = 0;
        clearTimer(T2);
        return Attach;
    }
    return Forward;
}

SystemStateType VerifyStrongestSignalState() {
    return VerifyStrongestSignal;
}

/**
 * When robot detected a wall, back up for 1 second, reset all global variables, and return to
 * AcquireStrongestSignal state to relocate beacon.
 * Pre-conditions:
 * Post-conditions:
 *
 * @return      the next SystemState to transition to
 */
SystemStateType WallDetectedState() {
    const int backup_time = 1000;
    const int acceleration_time = backup_time / 2;
    //    motor[left] = motor[right] = -50;
    const int base_speed = -25;
    const int max_speed = -100;
    const int k = -75;
    static int motorSpeed;

    if (time1[T2] < acceleration_time) {
        //accelerate for half the total time
        motorSpeed = base_speed + k * 1.0 * time1[T2] / acceleration_time;
    } else {
        motorSpeed = max_speed;
    }

    drive_forward(motorSpeed);

    if (SensorValue(button1)) {
        drive_forward(50);
        clearTimer(T2);
        while (time1[T2] < 750) {
            if (SensorValue[ultrasonic] < ultrasonic_threshold && SensorValue[ultrasonic] >= 0) {
                initialize_global_variables();
                initialize_LED();
                clearTimer(T2);
                return WallDetected;
            }
        }
        return AcquireStrongestSignal;
    }
    if (time1[T2] > backup_time) {
        //if backup_time has elapsed
        motor[left] = motor[right] = 0;
        sleep(250);
        clearTimer(T2);

        return AcquireStrongestSignal;
    }
    return WallDetected;
}

/**
 * Lower attachment mechanism and then return Release state
 * Pre-conditions: Robot movement must have ceased
 * Post-conditions: attachment mechanism is lowered
 *
 * @return      Release, the next SystemState to transition to
 */
 bool attach_success = false;
SystemStateType AttachState() {
    motor[lift] = 100; //40 //lower attachment mechanism

    if (SensorValue[ultrasonic] > ultrasonic_cable_connection_threshold +2) {
    	// && !attach_success && time1[T2] % 500 <= 15) {
    		attach_success = false;
  	} else {
  	attach_success = true;
  	}
    //sleep(2600);
  	if (time1[T2] > 900) { //2600
  			if (!attach_success) {
  					motor[lift] = -50;
       		  sleep(1500); //2250 //2300 //2320
       		  motor[lift] = 0;

      		  return Forward;
  			}
   		 	motor[lift] = 0; //stop motor

    		clearTimer(T2);
    		return Release;
  	}
  	return Attach;
}

/**
 * Back up and then raise attachment mechanism
 * Pre-conditions: attachment mechanism is lowered
 * Post-conditions: Robot has stopped motion, lift is raised again (during testing only)
 *
 * @return      Idle, the next SystemState to transition to
 */
SystemStateType ReleaseState() {
    const int backup_time = 1000;
    const int acceleration_time = backup_time / 2;
    //    motor[left] = motor[right] = -50;
    const int base_speed = -25;
    const int max_speed = -100;
    const int k = -75;
    static int motorSpeed;

    if (time1[T2] < acceleration_time) {
        //accelerate for half the total time
        motorSpeed = base_speed + k * 1.0 * time1[T2] / acceleration_time;
    } else {
        motorSpeed = max_speed;
    }

    drive_forward(motorSpeed);
    //    sleep(1000);
    if (time1[T2] > backup_time || SensorValue(button1)) {
        //if backup_time has elapsed, or robot has backed into something, stop
        motor[left] = motor[right] = 0;
        sleep(500);

        motor[lift] = -50;
        sleep(1500); //2250 //2300 //2320
        motor[lift] = 0;
        SensorValue[StateLEDCompletion] = 1;
        clearTimer(T2);
        clearTimer(T3);

        return Idle;
    }
    return Release;
}

/**
 * Blinks all LEDs on the LED bar at 2 Hz
 * Pre-conditions:
 * Post-conditions:
 *
 */
void blink_LED() {
    const int blink_time = 250;
    if (time1[T3] > blink_time * 2) {
        clearTimer(T3);
    } else if (time1[T3] > blink_time) {
        set_LED(0);
    } else {
        set_LED(1);
    }
}

/**
 * Runs entire procedure
 *
 */
void run_program() {
    SystemStateType SystemState = Idle;
    SystemStateType NewState = Idle;
    while (true) {
        monitorLight();
//        validate_connection_distance();
        switch (SystemState) {
            case Idle:
                initialize_motors();
                initialize_global_variables();
                blink_LED();

                if(SensorValue(button1)){
                    initialize_LED(); //turn all LEDs off
                    NewState = AcquireStrongestSignal;
                    clearTimer(T2);
                }
                break;
            case AcquireStrongestSignal:
                SensorValue[StateLEDAcquire] = 1;
                NewState = AcquireStrongestSignalState();
                break;
            case RotateToStrongestSignal:
                SensorValue[StateLEDRotate] = 1;
                //motor[left] = motor[right] = 50;
                NewState = RotateToStrongestSignalState();
                break;
            case Forward:
                SensorValue[StateLEDForward] = 1;
                NewState = ForwardState();
                break;
            case VerifyStrongestSignal:
                SensorValue[StateLEDVerify] = 1;
                NewState = VerifyStrongestSignalState();
                break;
            case Attach:
                SensorValue[StateLEDAttach] = 1;
                NewState = AttachState();
                break;
            case Release:
                NewState = ReleaseState();
                break;
            case WallDetected:
                NewState = WallDetectedState();
                break;
            default:
                // should never go here
        }
        //        if ( NewState != SystemState )
        //        clearTimer(T2); // Reset timer when state changes.
        SystemState = NewState; // Set new state for next loop.
    }
}

task main() {
    initialize_LED();
    initialize_motors();

    run_program();
}
